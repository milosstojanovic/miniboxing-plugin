scala> import MbReflection._
import MbReflection._

scala> class C[@miniboxed T] { override def toString: String = s"C[T = ${reifiedType[T]}, miniboxed into a ${storageType[T]}]" }
defined class C

scala> new C[Int]
res0: C[Int] = C[T = int, miniboxed into a long]

scala> new C[Unit]
res1: C[Unit] = C[T = unit, miniboxed into a long]

scala> new C[Float]
res2: C[Float] = C[T = float, miniboxed into a double]

scala> def newC[T] = new C[T]
<console>:11: warning: The following code could benefit from miniboxing specialization if the type parameter T of method newC would be marked as "@miniboxed T" (it would be used to instantiate miniboxed type parameter T of class C)
       def newC[T] = new C[T]
                     ^
newC: [T]=> C[T]

scala> newC[Int]
<console>:13: warning: The method newC would benefit from miniboxing type parameter T, since it is instantiated by a primitive type.
              newC[Int]
                  ^
res3: C[Int] = C[T = reference, miniboxed into a reference]

scala> class D[@miniboxed T] { if (!isMiniboxed[T]) println("Idiot!") }
defined class D

scala> new D[Int]
res4: D[Int] = D_J@<object_id>

scala> new D[String]
Idiot!
res5: D[String] = D_L@<object_id>

scala> def foo[@miniboxed T]: Unit = if (isMiniboxed[T]) println("miniboxed") else println("generic")
foo: [T]=> Unit

scala> foo[Byte]
miniboxed

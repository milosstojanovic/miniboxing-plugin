Specializing class MBList...
  // interface:
  abstract trait MBList[T] extends Object {
    def contains(e: T): Boolean
    def contains_J(val T_TypeTag: Byte,e: T @storage[Long]): Boolean
    def length(): Int
    def length_J(val T_TypeTag: Byte): Int
    def toString2(): String
    def toString2_J(val T_TypeTag: Byte): String
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[T],e: T): Boolean
    final private[this] def containsTail_J(val T_TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[T],e: T @storage[Long]): Boolean
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[T],or: Int): Int
    final private[this] def tailHash_J(val T_TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[T],or: Int): Int
    override def hashCode(): Int
    override def hashCode_J(val T_TypeTag: Byte): Int
    override def toString(): String
    override def toString_J(val T_TypeTag: Byte): String
    val head(): T
    val head_J(val T_TypeTag: Byte): T @storage[Long]
    val tail(): miniboxing.benchmarks.minibox.MBList[T]
    val tail_J(val T_TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[T]
  }
  // specialized class:
  class MBList_J[Tsp] extends MBList[Tsp] {
    def <init>(val miniboxing|benchmarks|minibox|MBList_J|T_TypeTag: Byte,head: Tsp @storage[Long],tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList_J[Tsp] // is a specialized implementation of constructor MBList
    def contains(e: Tsp): Boolean                                          // is a forwarder to the specialized member
    def contains_J(val T_TypeTag: Byte,e: Tsp @storage[Long]): Boolean     // is a specialized implementation of method contains
    def length(): Int                                                      // is a forwarder to the specialized member
    def length_J(val T_TypeTag: Byte): Int                                 // is a specialized implementation of method length
    def toString2(): String                                                // is a forwarder to the specialized member
    def toString2_J(val T_TypeTag: Byte): String                           // is a specialized implementation of method toString2
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp): Boolean // is a forwarder to the specialized member
    final private[this] def containsTail_J(val T_TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp @storage[Long]): Boolean // is a specialized implementation of method containsTail
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a forwarder to the specialized member
    final private[this] def tailHash_J(val T_TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a specialized implementation of method tailHash
    override def hashCode(): Int                                           // is a forwarder to the specialized member
    override def hashCode_J(val T_TypeTag: Byte): Int                      // is a specialized implementation of method hashCode
    override def toString(): String                                        // is a forwarder to the specialized member
    override def toString_J(val T_TypeTag: Byte): String                   // is a specialized implementation of method toString
    private[this] val head: Tsp @storage[Long]                             // is a specialized implementation of value head
    private[this] val miniboxing|benchmarks|minibox|MBList_J|T_TypeTag: Byte // is a type tag
    private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp]      // is a specialized implementation of value tail
    val head(): Tsp                                                        // is a forwarder to the specialized member
    val head_J(val T_TypeTag: Byte): Tsp @storage[Long]                    // is a setter or getter for value head
    val tail(): miniboxing.benchmarks.minibox.MBList[Tsp]                  // is a forwarder to the specialized member
    val tail_J(val T_TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] // is a setter or getter for value tail
  }
  // specialized class:
  class MBList_L[Tsp] extends MBList[Tsp] {
    def <init>(head: Tsp,tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList_L[Tsp] // is a specialized implementation of constructor MBList
    def contains(e: Tsp): Boolean                                          // is a specialized implementation of method contains
    def contains_J(val T_TypeTag: Byte,e: Tsp @storage[Long]): Boolean     // is a forwarder to the specialized member
    def length(): Int                                                      // is a specialized implementation of method length
    def length_J(val T_TypeTag: Byte): Int                                 // is a forwarder to the specialized member
    def toString2(): String                                                // is a specialized implementation of method toString2
    def toString2_J(val T_TypeTag: Byte): String                           // is a forwarder to the specialized member
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp): Boolean // is a specialized implementation of method containsTail
    final private[this] def containsTail_J(val T_TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp @storage[Long]): Boolean // is a forwarder to the specialized member
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a specialized implementation of method tailHash
    final private[this] def tailHash_J(val T_TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a forwarder to the specialized member
    override def hashCode(): Int                                           // is a specialized implementation of method hashCode
    override def hashCode_J(val T_TypeTag: Byte): Int                      // is a forwarder to the specialized member
    override def toString(): String                                        // is a specialized implementation of method toString
    override def toString_J(val T_TypeTag: Byte): String                   // is a forwarder to the specialized member
    private[this] val head: Tsp                                            // is a specialized implementation of value head
    private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp]      // is a specialized implementation of value tail
    val head(): Tsp                                                        // is a setter or getter for value head
    val head_J(val T_TypeTag: Byte): Tsp @storage[Long]                    // is a forwarder to the specialized member
    val tail(): miniboxing.benchmarks.minibox.MBList[Tsp]                  // is a setter or getter for value tail
    val tail_J(val T_TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] // is a forwarder to the specialized member
  }
[Now checking: minibox-inject]
[Now checking: minibox-bridge]
[Not checkable: minibox-coerce]
Miniboxing plugin warning: Optimizing `MbArray` is only possible if you allow the plugin to use both long and double encodings (remove `P:minibox:Yone-way` compiler option). `MbArray`-s will be generic and will box.
[[syntax trees at end of            minibox-commit]] // newSource1.scala
package miniboxing.benchmarks.minibox {
  abstract trait MBList[@miniboxed T] extends Object {
    <stable> <accessor> <paramaccessor> def head(): T;
    <stable> <accessor> def head_J(T_TypeTag: Byte): Long;
    <stable> <accessor> <paramaccessor> def tail(): miniboxing.benchmarks.minibox.MBList[T];
    <stable> <accessor> def tail_J(T_TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[T];
    def length(): Int;
    def length_J(T_TypeTag: Byte): Int;
    override def toString(): String;
    override def toString_J(T_TypeTag: Byte): String;
    def contains(e: T): Boolean;
    def contains_J(T_TypeTag: Byte, e: Long): Boolean;
    override def hashCode(): Int;
    override def hashCode_J(T_TypeTag: Byte): Int;
    def toString2(): String;
    def toString2_J(T_TypeTag: Byte): String
  };
  class MBList_J[Tsp] extends Object with miniboxing.benchmarks.minibox.MBList[Tsp] {
    <paramaccessor> private[this] val miniboxing|benchmarks|minibox|MBList_J|T_TypeTag: Byte = _;
    <paramaccessor> private[this] val head: Long = _;
    <stable> <accessor> <paramaccessor> def head(): Tsp = MiniboxConversions.this.minibox2box[Tsp](MBList_J.this.head_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag), MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag);
    <stable> <accessor> def head_J(T_TypeTag: Byte): Long = MBList_J.this.head;
    <paramaccessor> private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp] = _;
    <stable> <accessor> <paramaccessor> def tail(): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList_J.this.tail_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag);
    <stable> <accessor> def tail_J(T_TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList_J.this.tail;
    def <init>(miniboxing|benchmarks|minibox|MBList_J|T_TypeTag: Byte, head: Long, tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList_J[Tsp] = {
      MBList_J.super.<init>();
      ()
    };
    def length(): Int = MBList_J.this.length_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag);
    def length_J(T_TypeTag: Byte): Int = 1.+(if (MBList_J.this.tail_J(T_TypeTag).!=(null))
      MBList_J.this.tail_J(T_TypeTag).length_J(T_TypeTag)
    else
      0);
    override def toString(): String = MBList_J.this.toString_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag);
    override def toString_J(T_TypeTag: Byte): String = MiniboxDispatch.this.mboxed_toString(MBList_J.this.head_J(T_TypeTag), T_TypeTag).+(if (MBList_J.this.tail_J(T_TypeTag).!=(null))
      ", ".+(MBList_J.this.tail_J(T_TypeTag).toString_J(T_TypeTag))
    else
      "");
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Tsp): Boolean = MBList_J.this.containsTail_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag, list, MiniboxConversions.this.box2minibox_tt[Tsp](e, MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag));
    final private[this] def containsTail_J(T_TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Long): Boolean = if (MiniboxDispatch.this.mboxed_eqeq_notag(list.head_J(T_TypeTag), e))
      true
    else
      if (list.tail_J(T_TypeTag).==(null))
        false
      else
        MBList_J.this.containsTail_J(T_TypeTag, list.tail_J(T_TypeTag), e);
    def contains(e: Tsp): Boolean = MBList_J.this.contains_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag, MiniboxConversions.this.box2minibox_tt[Tsp](e, MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag));
    def contains_J(T_TypeTag: Byte, e: Long): Boolean = MBList_J.this.containsTail_J(T_TypeTag, MBList_J.this, e);
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = MBList_J.this.tailHash_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag, list, or);
    final private[this] def tailHash_J(T_TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = {
      val headhash: Int = MiniboxDispatch.this.mboxed_hashCode(list.head_J(T_TypeTag), T_TypeTag);
      if (list.tail_J(T_TypeTag).==(null))
        headhash.|(or)
      else
        MBList_J.this.tailHash_J(T_TypeTag, list.tail_J(T_TypeTag), or.|(headhash.>>(8)))
    };
    override def hashCode(): Int = MBList_J.this.hashCode_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag);
    override def hashCode_J(T_TypeTag: Byte): Int = MBList_J.this.tailHash_J(T_TypeTag, MBList_J.this, 0);
    def toString2(): String = MBList_J.this.toString2_J(MBList_J.this.miniboxing|benchmarks|minibox|MBList_J|T_TypeTag);
    def toString2_J(T_TypeTag: Byte): String = MBList_J.this.toString_J(T_TypeTag)
  };
  class MBList_L[Tsp] extends Object with miniboxing.benchmarks.minibox.MBList[Tsp] {
    <paramaccessor> private[this] val head: Tsp = _;
    <stable> <accessor> <paramaccessor> def head(): Tsp = MBList_L.this.head;
    <stable> <accessor> def head_J(T_TypeTag: Byte): Long = MiniboxConversions.this.box2minibox_tt[Tsp](MBList_L.this.head(), T_TypeTag);
    <paramaccessor> private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp] = _;
    <stable> <accessor> <paramaccessor> def tail(): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList_L.this.tail;
    <stable> <accessor> def tail_J(T_TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList_L.this.tail();
    def <init>(head: Tsp, tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList_L[Tsp] = {
      MBList_L.super.<init>();
      ()
    };
    def length(): Int = 1.+(if (MBList_L.this.tail().!=(null))
      MBList_L.this.tail().length()
    else
      0);
    def length_J(T_TypeTag: Byte): Int = MBList_L.this.length();
    override def toString(): String = MBList_L.this.head().toString().+(if (MBList_L.this.tail().!=(null))
      ", ".+(MBList_L.this.tail().toString())
    else
      "");
    override def toString_J(T_TypeTag: Byte): String = MBList_L.this.toString();
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Tsp): Boolean = if (list.head().==(e))
      true
    else
      if (list.tail().==(null))
        false
      else
        MBList_L.this.containsTail(list.tail(), e);
    final private[this] def containsTail_J(T_TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Long): Boolean = MBList_L.this.containsTail(list, MiniboxConversions.this.minibox2box[Tsp](e, T_TypeTag));
    def contains(e: Tsp): Boolean = MBList_L.this.containsTail(MBList_L.this, e);
    def contains_J(T_TypeTag: Byte, e: Long): Boolean = MBList_L.this.contains(MiniboxConversions.this.minibox2box[Tsp](e, T_TypeTag));
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = {
      val headhash: Int = list.head().hashCode();
      if (list.tail().==(null))
        headhash.|(or)
      else
        MBList_L.this.tailHash(list.tail(), or.|(headhash.>>(8)))
    };
    final private[this] def tailHash_J(T_TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = MBList_L.this.tailHash(list, or);
    override def hashCode(): Int = MBList_L.this.tailHash(MBList_L.this, 0);
    override def hashCode_J(T_TypeTag: Byte): Int = MBList_L.this.hashCode();
    def toString2(): String = MBList_L.this.toString();
    def toString2_J(T_TypeTag: Byte): String = MBList_L.this.toString2()
  }
}
[Now checking: minibox-commit]